var searchIndex = {};
searchIndex['queryst'] = {"items":[[0,"","queryst",""],[1,"ParseError","",""],[11,"kind","","",0],[11,"message","","",0],[2,"ParseErrorKind","",""],[12,"DecodingError","","",1],[12,"Other","","",1],[3,"parse","",""],[10,"as_object_mut","rustc-serialize::json","If the Json value is an Object, returns the associated TreeMap.\nReturns None otherwise.",2],[10,"as_array_mut","","",2],[10,"fmt","queryst","",1],[10,"fmt","","",0],[4,"ParseResult","",""]],"paths":[[1,"ParseError"],[2,"ParseErrorKind"],[2,"Json"]]};
searchIndex['url'] = {"items":[[0,"","url","<a href=\"https://github.com/servo/rust-url\"><img style=\"position: absolute; top: 0; left: 0; border: 0;\" src=\"../github.png\" alt=\"Fork me on GitHub\"></a>\n<style>.sidebar { margin-top: 53px }</style>"],[1,"Ipv6Address","","A 128 bit IPv6 address"],[11,"pieces","","",0],[1,"Url","","The parsed representation of an absolute URL."],[11,"scheme","","The scheme (a.k.a. protocol) of the URL, in ASCII lower case.",1],[11,"scheme_data","","The components of the URL whose representation depends on where the scheme is *relative*.",1],[11,"query","","The query string of the URL.",1],[11,"fragment","","The fragment identifier of the URL.",1],[1,"RelativeSchemeData","","Components for URLs in a *relative* scheme such as HTTP."],[11,"username","","The username of the URL, as a possibly empty, pecent-encoded string.",2],[11,"password","","The password of the URL.",2],[11,"host","","The host of the URL, either a domain name or an IPv4 address",2],[11,"port","","The port number of the URL.\n`None` for file-like schemes, or to indicate the default port number.",2],[11,"default_port","","The default port number for the URL’s scheme.\n`None` for file-like schemes.",2],[11,"path","","The path of the URL, as vector of pecent-encoded strings.",2],[1,"UrlParser","","A set of optional parameters for URL parsing."],[2,"Host","","The host name of an URL."],[12,"Domain","","A (DNS) domain name or an IPv4 address.",3],[12,"Ipv6","","An IPv6 address, represented inside `[...]` square brackets\nso that `:` colon characters in the address are not ambiguous\nwith the port number delimiter.",3],[2,"ParseError","","Errors that can occur during parsing."],[12,"EmptyHost","","",4],[12,"InvalidScheme","","",4],[12,"InvalidPort","","",4],[12,"InvalidIpv6Address","","",4],[12,"InvalidDomainCharacter","","",4],[12,"InvalidCharacter","","",4],[12,"InvalidBackslash","","",4],[12,"InvalidPercentEncoded","","",4],[12,"InvalidAtSymbolInUser","","",4],[12,"ExpectedTwoSlashes","","",4],[12,"ExpectedInitialSlash","","",4],[12,"NonUrlCodePoint","","",4],[12,"RelativeUrlWithScheme","","",4],[12,"RelativeUrlWithoutBase","","",4],[12,"RelativeUrlWithNonRelativeBase","","",4],[12,"NonAsciiDomainsNotSupportedYet","","",4],[12,"CannotSetJavascriptFragment","","",4],[12,"CannotSetPortWithFileLikeScheme","","",4],[12,"CannotSetUsernameWithNonRelativeScheme","","",4],[12,"CannotSetPasswordWithNonRelativeScheme","","",4],[12,"CannotSetHostPortWithNonRelativeScheme","","",4],[12,"CannotSetHostWithNonRelativeScheme","","",4],[12,"CannotSetPortWithNonRelativeScheme","","",4],[12,"CannotSetPathWithNonRelativeScheme","","",4],[2,"SchemeData","","The components of the URL whose representation depends on where the scheme is *relative*."],[12,"Relative","","Components for URLs in a *relative* scheme such as HTTP.",5],[12,"NonRelative","","No further structure is assumed for *non-relative* schemes such as `data` and `mailto`.",5],[2,"SchemeType","","Determines the behavior of the URL parser for a given scheme."],[12,"NonRelative","","Indicate that the scheme is *non-relative*.",6],[12,"Relative","","Indicate that the scheme is *relative*, and what the default port number is.",6],[12,"FileLike","","Indicate a *relative* scheme similar to the *file* scheme.",6],[3,"parse_path","","Parse `input` as a “standalone” URL path,\nwith an optional query string and fragment identifier."],[3,"whatwg_scheme_type_mapper","","http://url.spec.whatwg.org/#relative-scheme"],[10,"fmt","","",3],[10,"clone","","",3],[10,"eq","","",3],[10,"ne","","",3],[10,"fmt","","",0],[10,"eq","","",0],[10,"ne","","",0],[10,"clone","","",0],[10,"parse","","Parse a host: either an IPv6 address in [] square brackets, or a domain.",3],[10,"serialize","","Serialize the host as a string.",3],[10,"fmt","","",3],[10,"parse","","Parse an IPv6 address, without the [] square brackets.",0],[10,"serialize","","Serialize the IPv6 address to a string.",0],[10,"fmt","","",0],[10,"fmt","","",4],[10,"clone","","",4],[10,"eq","","",4],[10,"ne","","",4],[10,"description","","",4],[10,"fmt","","",4],[0,"percent_encoding","",""],[1,"EncodeSet","url::percent_encoding","Represents a set of characters / bytes that should be percent-encoded."],[3,"percent_encode_to","","Percent-encode the given bytes, and push the result to `output`."],[3,"percent_encode","","Percent-encode the given bytes."],[3,"utf8_percent_encode_to","","Percent-encode the UTF-8 encoding of the given string, and push the result to `output`."],[3,"utf8_percent_encode","","Percent-encode the UTF-8 encoding of the given string."],[3,"percent_decode_to","","Percent-decode the given bytes, and push the result to `output`."],[3,"percent_decode","","Percent-decode the given bytes."],[3,"lossy_utf8_percent_decode","","Percent-decode the given bytes, and decode the result as UTF-8."],[3,"from_hex","",""],[5,"SIMPLE_ENCODE_SET","","This encode set is used for fragment identifier and non-relative scheme data."],[5,"QUERY_ENCODE_SET","","This encode set is used in the URL parser for query strings."],[5,"DEFAULT_ENCODE_SET","","This encode set is used for path components."],[5,"USERINFO_ENCODE_SET","","This encode set is used in the URL parser for usernames and passwords."],[5,"PASSWORD_ENCODE_SET","","This encode set should be used when setting the password field of a parsed URL."],[5,"USERNAME_ENCODE_SET","","This encode set should be used when setting the username field of a parsed URL."],[5,"FORM_URLENCODED_ENCODE_SET","","This encode set is used in `application/x-www-form-urlencoded` serialization."],[0,"form_urlencoded","url","Parser and serializer for the [`application/x-www-form-urlencoded` format](\nhttp://url.spec.whatwg.org/#application/x-www-form-urlencoded),\nas used by HTML forms."],[3,"parse","url::form_urlencoded","Convert a byte string in the `application/x-www-form-urlencoded` format\ninto a vector of (name, value) pairs."],[3,"serialize_owned","","Convert a slice of owned (name, value) pairs\ninto a string in the `application/x-www-form-urlencoded` format."],[3,"serialize","","Convert an iterator of (name, value) pairs\ninto a string in the `application/x-www-form-urlencoded` format."],[0,"punycode","url","Punycode ([RFC 3492](http://tools.ietf.org/html/rfc3492)) implementation."],[3,"decode_to_string","url::punycode","Convert Punycode to an Unicode `String`."],[3,"decode","","Convert Punycode to Unicode."],[3,"encode_str","","Convert an Unicode `str` to Punycode."],[3,"encode","","Convert Unicode to Punycode."],[0,"format","url","Formatting utilities for URLs."],[1,"PathFormatter","url::format","Formatter and serializer for URL path data."],[11,"path","","The path as a slice of string-like objects (String or &str).",7],[1,"UserInfoFormatter","","Formatter and serializer for URL username and password data."],[11,"username","","URL username as a string slice.",8],[11,"password","","URL password as an optional string slice.",8],[1,"UrlNoFragmentFormatter","","Formatter for URLs which ignores the fragment field."],[11,"url","","",9],[10,"fmt","","",7],[10,"fmt","","",8],[10,"fmt","","",9],[4,"ErrorHandler","url","This is called on non-fatal parse errors."],[4,"ParseResult","",""],[6,"ToUrlPath","",""],[9,"to_url_path","","",10],[6,"FromUrlPath","",""],[9,"from_url_path","","",11],[10,"fmt","","",1],[10,"clone","","",1],[10,"eq","","",1],[10,"ne","","",1],[10,"fmt","","",5],[10,"clone","","",5],[10,"eq","","",5],[10,"ne","","",5],[10,"fmt","","",2],[10,"clone","","",2],[10,"eq","","",2],[10,"ne","","",2],[10,"hash","","",1],[10,"new","","Return a new UrlParser with default parameters.",12],[10,"base_url","","Set the base URL used for resolving relative URL references, and return the `UrlParser`.\nThe default is no base URL, so that relative URLs references fail to parse.",12],[10,"error_handler","","Set an error handler for non-fatal parse errors, and return the `UrlParser`.",12],[10,"scheme_type_mapper","","Set a *scheme type mapper*, and return the `UrlParser`.",12],[10,"parse","","Parse `input` as an URL, with all the parameters previously set in the `UrlParser`.",12],[10,"parse_path","","Parse `input` as a “standalone” URL path,\nwith an optional query string and fragment identifier.",12],[10,"fmt","","",6],[10,"eq","","",6],[10,"ne","","",6],[10,"default_port","","",6],[10,"parse","","Parse an URL with the default `UrlParser` parameters.",1],[10,"from_file_path","","Convert a file name as `std::path::Path` into an URL in the `file` scheme.",1],[10,"from_directory_path","","Convert a directory name as `std::path::Path` into an URL in the `file` scheme.",1],[10,"to_file_path","","Assuming the URL is in the `file` scheme or similar,\nconvert its path to an absolute `std::path::Path`.",1],[10,"serialize","","Return the serialization of this URL as a string.",1],[10,"serialize_no_fragment","","Return the serialization of this URL, without the fragment identifier, as a string",1],[10,"non_relative_scheme_data","","If the URL is *non-relative*, return the string scheme data.",1],[10,"non_relative_scheme_data_mut","","If the URL is *non-relative*, return a mutable reference to the string scheme data.",1],[10,"relative_scheme_data","","If the URL is in a *relative scheme*, return the structured scheme data.",1],[10,"relative_scheme_data_mut","","If the URL is in a *relative scheme*,\nreturn a mutable reference to the structured scheme data.",1],[10,"username","","If the URL is in a *relative scheme*, return its username.",1],[10,"username_mut","","If the URL is in a *relative scheme*, return a mutable reference to its username.",1],[10,"lossy_percent_decode_username","","Percent-decode the URL’s username, if any.",1],[10,"password","","If the URL is in a *relative scheme*, return its password, if any.",1],[10,"password_mut","","If the URL is in a *relative scheme*, return a mutable reference to its password, if any.",1],[10,"lossy_percent_decode_password","","Percent-decode the URL’s password, if any.",1],[10,"serialize_userinfo","","Serialize the URL's username and password, if any.",1],[10,"host","","If the URL is in a *relative scheme*, return its structured host.",1],[10,"host_mut","","If the URL is in a *relative scheme*, return a mutable reference to its structured host.",1],[10,"domain","","If the URL is in a *relative scheme* and its host is a domain,\nreturn the domain as a string.",1],[10,"domain_mut","","If the URL is in a *relative scheme* and its host is a domain,\nreturn a mutable reference to the domain string.",1],[10,"serialize_host","","If the URL is in a *relative scheme*, serialize its host as a string.",1],[10,"port","","If the URL is in a *relative scheme* and has a port number, return it.",1],[10,"port_mut","","If the URL is in a *relative scheme*, return a mutable reference to its port.",1],[10,"port_or_default","","If the URL is in a *relative scheme* that is not a file-like,\nreturn its port number, even if it is the default.",1],[10,"path","","If the URL is in a *relative scheme*, return its path components.",1],[10,"path_mut","","If the URL is in a *relative scheme*, return a mutable reference to its path components.",1],[10,"serialize_path","","If the URL is in a *relative scheme*, serialize its path as a string.",1],[10,"query_pairs","","Parse the URL’s query string, if any, as `application/x-www-form-urlencoded`\nand return a vector of (key, value) pairs.",1],[10,"set_query_from_pairs","","Serialize an iterator of (key, value) pairs as `application/x-www-form-urlencoded`\nand set it as the URL’s query string.",1],[10,"lossy_percent_decode_query","","Percent-decode the URL’s query string, if any.",1],[10,"lossy_percent_decode_fragment","","Percent-decode the URL’s fragment identifier, if any.",1],[10,"encode","","",1],[10,"decode","","",1],[10,"fmt","","",1],[10,"fmt","","",5],[10,"lossy_percent_decode_username","","Percent-decode the URL’s username.",2],[10,"lossy_percent_decode_password","","Percent-decode the URL’s password, if any.",2],[10,"to_file_path","","Assuming the URL is in the `file` scheme or similar,\nconvert its path to an absolute `std::path::Path`.",2],[10,"domain","","If the host is a domain, return the domain as a string.",2],[10,"domain_mut","","If the host is a domain, return a mutable reference to the domain string.",2],[10,"port_or_default","","Return the port number of the URL, even if it is the default.\nReturn `None` for file-like URLs.",2],[10,"serialize_path","","Serialize the path as a string.",2],[10,"serialize_userinfo","","Serialize the userinfo as a string.",2],[10,"fmt","","",2],[10,"to_url_path","std::path::posix","",13],[10,"to_url_path","std::path::windows","",14],[10,"from_url_path","std::path::posix","",13],[10,"from_url_path","std::path::windows","",14]],"paths":[[1,"Ipv6Address"],[1,"Url"],[1,"RelativeSchemeData"],[2,"Host"],[2,"ParseError"],[2,"SchemeData"],[2,"SchemeType"],[1,"PathFormatter"],[1,"UserInfoFormatter"],[1,"UrlNoFragmentFormatter"],[6,"ToUrlPath"],[6,"FromUrlPath"],[1,"UrlParser"],[1,"Path"],[1,"Path"]]};

searchIndex['regex_macros'] = {"items":[[0,"","regex_macros","This crate provides the `regex!` macro. Its use is documented in the\n`regex` crate."]],"paths":[]};

searchIndex['rustc-serialize'] = {"items":[[0,"","rustc-serialize","Support code for encoding and decoding types."],[10,"encode","collections::string","",0],[10,"decode","","",0],[10,"encode","alloc::boxed","",1],[10,"decode","","",1],[10,"decode","","",1],[10,"encode","alloc::rc","",2],[10,"decode","","",2],[10,"encode","collections::vec","",3],[10,"decode","","",3],[10,"encode","core::option","",4],[10,"decode","","",4],[10,"encode","std::path::posix","",5],[10,"decode","","",5],[10,"encode","std::path::windows","",6],[10,"decode","","",6],[10,"encode","core::cell","",7],[10,"decode","","",7],[10,"encode","","",8],[10,"decode","","",8],[10,"encode","alloc::arc","",9],[10,"decode","","",9],[10,"encode","collections::dlist","",10],[10,"decode","","",10],[10,"encode","collections::ring_buf","",11],[10,"decode","","",11],[10,"encode","collections::btree::map","",12],[10,"decode","","",12],[10,"encode","collections::btree::set","",13],[10,"decode","","",13],[10,"encode","std::collections::hash::map","",14],[10,"decode","","",14],[10,"encode","std::collections::hash::set","",15],[10,"decode","","",15],[10,"encode","collections::vec_map","",16],[10,"decode","","",16],[0,"base64","rustc-serialize","Base64 binary-to-text encoding"],[1,"Config","rustc-serialize::base64","Contains configuration parameters for `to_base64`."],[11,"char_set","","Character set to use",17],[11,"newline","","Newline to use",17],[11,"pad","","True to pad output with `=` characters",17],[11,"line_length","","`Some(len)` to wrap lines at `len`, `None` to disable line wrapping",17],[2,"CharacterSet","","Available encoding character sets"],[12,"Standard","","The standard character set (uses `+` and `/`)",18],[12,"UrlSafe","","The URL safe character set (uses `-` and `_`)",18],[2,"Newline","","Available newline types"],[12,"LF","","A linefeed (i.e. Unix-style newline)",19],[12,"CRLF","","A carriage return and a linefeed (i.e. Windows-style newline)",19],[2,"FromBase64Error","","Errors that can occur when decoding a base64 encoded string"],[12,"InvalidBase64Byte","","The input contained a character not part of the base64 format",20],[12,"InvalidBase64Length","","The input had an invalid length",20],[5,"STANDARD","","Configuration for RFC 4648 standard base64 encoding"],[5,"URL_SAFE","","Configuration for RFC 4648 base64url encoding"],[5,"MIME","","Configuration for RFC 2045 MIME base64 encoding"],[6,"ToBase64","","A trait for converting a value to base64 encoding."],[9,"to_base64","","Converts the value of `self` to a base64 value following the specified\nformat configuration, returning the owned string.",21],[6,"FromBase64","","A trait for converting from base64 encoded values."],[9,"from_base64","","Converts the value of `self`, interpreted as base64 encoded data, into\nan owned vector of bytes, returning the vector.",22],[10,"fmt","","",20],[10,"description","","",20],[10,"detail","","",20],[0,"hex","rustc-serialize","Hex binary-to-text encoding"],[2,"FromHexError","rustc-serialize::hex","Errors that can occur when decoding a hex encoded string"],[12,"InvalidHexCharacter","","The input contained a character not part of the hex format",23],[12,"InvalidHexLength","","The input had an invalid length",23],[6,"ToHex","","A trait for converting a value to hexadecimal encoding"],[9,"to_hex","","Converts the value of `self` to a hex value, returning the owned\nstring.",24],[6,"FromHex","","A trait for converting hexadecimal encoded values"],[9,"from_hex","","Converts the value of `self`, interpreted as hexadecimal encoded data,\ninto an owned vector of bytes, returning the vector.",25],[10,"fmt","","",23],[10,"description","","",23],[10,"detail","","",23],[0,"json","rustc-serialize","JSON parsing and serialization"],[1,"PrettyJson","rustc-serialize::json",""],[1,"AsJson","",""],[1,"AsPrettyJson","",""],[1,"Encoder","","A structure for implementing serialization to JSON."],[1,"PrettyEncoder","","Another encoder for JSON, but prints out human-readable JSON instead of\ncompact data"],[1,"Stack","","A Stack represents the current position of the parser in the logical\nstructure of the JSON stream.\nFor example foo.bar[3].x"],[1,"Parser","","A streaming JSON parser implemented as an iterator of JsonEvent, consuming\nan iterator of char."],[1,"Builder","","A Builder consumes a json::Parser to create a generic Json structure."],[1,"Decoder","","A structure to decode JSON to values in rust."],[2,"Json","","Represents a json value"],[12,"I64","","",26],[12,"U64","","",26],[12,"F64","","",26],[12,"String","","",26],[12,"Boolean","","",26],[12,"Array","","",26],[12,"Object","","",26],[12,"Null","","",26],[2,"ErrorCode","","The errors that can arise while parsing a JSON stream."],[12,"InvalidSyntax","","",27],[12,"InvalidNumber","","",27],[12,"EOFWhileParsingObject","","",27],[12,"EOFWhileParsingArray","","",27],[12,"EOFWhileParsingValue","","",27],[12,"EOFWhileParsingString","","",27],[12,"KeyMustBeAString","","",27],[12,"ExpectedColon","","",27],[12,"TrailingCharacters","","",27],[12,"TrailingComma","","",27],[12,"InvalidEscape","","",27],[12,"InvalidUnicodeCodePoint","","",27],[12,"LoneLeadingSurrogateInHexEscape","","",27],[12,"UnexpectedEndOfHexEscape","","",27],[12,"UnrecognizedHex","","",27],[12,"NotFourDigit","","",27],[12,"NotUtf8","","",27],[2,"ParserError","",""],[12,"SyntaxError","","msg, line, col",28],[12,"IoError","","",28],[2,"DecoderError","",""],[12,"ParseError","","",29],[12,"ExpectedError","","",29],[12,"MissingFieldError","","",29],[12,"UnknownVariantError","","",29],[12,"ApplicationError","","",29],[2,"JsonEvent","","The output of the streaming parser."],[12,"ObjectStart","","",30],[12,"ObjectEnd","","",30],[12,"ArrayStart","","",30],[12,"ArrayEnd","","",30],[12,"BooleanValue","","",30],[12,"I64Value","","",30],[12,"U64Value","","",30],[12,"F64Value","","",30],[12,"StringValue","","",30],[12,"NullValue","","",30],[12,"Error","","",30],[2,"StackElement","","StackElements compose a Stack.\nFor example, Key(\"foo\"), Key(\"bar\"), Index(3) and Key(\"x\") are the\nStackElements compositing the stack that represents foo.bar[3].x"],[12,"Index","","",31],[12,"Key","","",31],[3,"error_str","","Returns a readable error string for a given error code."],[3,"decode","","Shortcut function to decode a JSON `&str` into an object"],[3,"encode","","Shortcut function to encode a `T` into a JSON `String`"],[3,"as_json","","Create an `AsJson` wrapper which can be used to print a value as JSON\non-the-fly via `write!`"],[3,"as_pretty_json","","Create an `AsPrettyJson` wrapper which can be used to print a value as JSON\non-the-fly via `write!`"],[4,"Array","",""],[4,"Object","",""],[4,"BuilderError","",""],[4,"EncodeResult","",""],[4,"DecodeResult","",""],[6,"ToJson","","A trait for converting values to JSON"],[9,"to_json","","Converts the value of `self` to an instance of JSON",32],[10,"fmt","","",26],[10,"partial_cmp","","",26],[10,"lt","","",26],[10,"le","","",26],[10,"gt","","",26],[10,"ge","","",26],[10,"eq","","",26],[10,"ne","","",26],[10,"clone","","",26],[10,"eq","","",27],[10,"ne","","",27],[10,"clone","","",27],[10,"fmt","","",28],[10,"eq","","",28],[10,"ne","","",28],[10,"clone","","",28],[10,"fmt","","",29],[10,"eq","","",29],[10,"ne","","",29],[10,"clone","","",29],[10,"fmt","","",27],[10,"description","","",29],[10,"detail","","",29],[10,"cause","","",29],[10,"description","","",28],[10,"detail","","",28],[10,"new","","Creates a new JSON encoder whose output will be written to the writer\nspecified.",33],[4,"Error","",""],[10,"emit_nil","","",33],[10,"emit_usize","","",33],[10,"emit_u64","","",33],[10,"emit_u32","","",33],[10,"emit_u16","","",33],[10,"emit_u8","","",33],[10,"emit_isize","","",33],[10,"emit_i64","","",33],[10,"emit_i32","","",33],[10,"emit_i16","","",33],[10,"emit_i8","","",33],[10,"emit_bool","","",33],[10,"emit_f64","","",33],[10,"emit_f32","","",33],[10,"emit_char","","",33],[10,"emit_str","","",33],[10,"emit_enum","","",33],[10,"emit_enum_variant","","",33],[10,"emit_enum_variant_arg","","",33],[10,"emit_enum_struct_variant","","",33],[10,"emit_enum_struct_variant_field","","",33],[10,"emit_struct","","",33],[10,"emit_struct_field","","",33],[10,"emit_tuple","","",33],[10,"emit_tuple_arg","","",33],[10,"emit_tuple_struct","","",33],[10,"emit_tuple_struct_arg","","",33],[10,"emit_option","","",33],[10,"emit_option_none","","",33],[10,"emit_option_some","","",33],[10,"emit_seq","","",33],[10,"emit_seq_elt","","",33],[10,"emit_map","","",33],[10,"emit_map_elt_key","","",33],[10,"emit_map_elt_val","","",33],[10,"new","","Creates a new encoder whose output will be written to the specified writer",34],[10,"set_indent","","Set the number of spaces to indent for each level.\nThis is safe to set during encoding.",34],[4,"Error","",""],[10,"emit_nil","","",34],[10,"emit_usize","","",34],[10,"emit_u64","","",34],[10,"emit_u32","","",34],[10,"emit_u16","","",34],[10,"emit_u8","","",34],[10,"emit_isize","","",34],[10,"emit_i64","","",34],[10,"emit_i32","","",34],[10,"emit_i16","","",34],[10,"emit_i8","","",34],[10,"emit_bool","","",34],[10,"emit_f64","","",34],[10,"emit_f32","","",34],[10,"emit_char","","",34],[10,"emit_str","","",34],[10,"emit_enum","","",34],[10,"emit_enum_variant","","",34],[10,"emit_enum_variant_arg","","",34],[10,"emit_enum_struct_variant","","",34],[10,"emit_enum_struct_variant_field","","",34],[10,"emit_struct","","",34],[10,"emit_struct_field","","",34],[10,"emit_tuple","","",34],[10,"emit_tuple_arg","","",34],[10,"emit_tuple_struct","","",34],[10,"emit_tuple_struct_arg","","",34],[10,"emit_option","","",34],[10,"emit_option_none","","",34],[10,"emit_option_some","","",34],[10,"emit_seq","","",34],[10,"emit_seq_elt","","",34],[10,"emit_map","","",34],[10,"emit_map_elt_key","","",34],[10,"emit_map_elt_val","","",34],[10,"encode","","",26],[10,"from_reader","","Decodes a json value from an `&mut io::Reader`",26],[10,"from_str","","Decodes a json value from a string",26],[10,"pretty","","Borrow this json object as a pretty object to generate a pretty\nrepresentation for it via `Show`.",26],[10,"find","","If the Json value is an Object, returns the value associated with the provided key.\nOtherwise, returns None.",26],[10,"find_path","","Attempts to get a nested Json Object for each key in `keys`.\nIf any key is found not to exist, find_path will return None.\nOtherwise, it will return the Json value associated with the final key.",26],[10,"search","","If the Json value is an Object, performs a depth-first search until\na value associated with the provided key is found. If no value is found\nor the Json value is not an Object, returns None.",26],[10,"is_object","","Returns true if the Json value is an Object. Returns false otherwise.",26],[10,"as_object","","If the Json value is an Object, returns the associated BTreeMap.\nReturns None otherwise.",26],[10,"is_array","","Returns true if the Json value is an Array. Returns false otherwise.",26],[10,"as_array","","If the Json value is an Array, returns the associated vector.\nReturns None otherwise.",26],[10,"is_string","","Returns true if the Json value is a String. Returns false otherwise.",26],[10,"as_string","","If the Json value is a String, returns the associated str.\nReturns None otherwise.",26],[10,"is_number","","Returns true if the Json value is a Number. Returns false otherwise.",26],[10,"is_i64","","Returns true if the Json value is a i64. Returns false otherwise.",26],[10,"is_u64","","Returns true if the Json value is a u64. Returns false otherwise.",26],[10,"is_f64","","Returns true if the Json value is a f64. Returns false otherwise.",26],[10,"as_i64","","If the Json value is a number, return or cast it to a i64.\nReturns None otherwise.",26],[10,"as_u64","","If the Json value is a number, return or cast it to a u64.\nReturns None otherwise.",26],[10,"as_f64","","If the Json value is a number, return or cast it to a f64.\nReturns None otherwise.",26],[10,"is_boolean","","Returns true if the Json value is a Boolean. Returns false otherwise.",26],[10,"as_boolean","","If the Json value is a Boolean, returns the associated bool.\nReturns None otherwise.",26],[10,"is_null","","Returns true if the Json value is a Null. Returns false otherwise.",26],[10,"as_null","","If the Json value is a Null, returns ().\nReturns None otherwise.",26],[4,"Output","",""],[10,"index","","",26],[4,"Output","",""],[10,"index","","",26],[10,"fmt","","",30],[10,"clone","","",30],[10,"eq","","",30],[10,"ne","","",30],[10,"fmt","","",31],[10,"clone","","",31],[10,"eq","","",31],[10,"ne","","",31],[10,"new","","",35],[10,"len","","Returns The number of elements in the Stack.",35],[10,"is_empty","","Returns true if the stack is empty.",35],[10,"get","","Provides access to the StackElement at a given index.\nlower indices are at the bottom of the stack while higher indices are\nat the top.",35],[10,"is_equal_to","","Compares this stack with an array of StackElements.",35],[10,"starts_with","","Returns true if the bottom-most elements of this stack are the same as\nthe ones passed as parameter.",35],[10,"ends_with","","Returns true if the top-most elements of this stack are the same as\nthe ones passed as parameter.",35],[10,"top","","Returns the top-most element (if any).",35],[4,"Item","",""],[10,"next","","",36],[10,"new","","Creates the JSON parser.",36],[10,"stack","","Provides access to the current position in the logical structure of the\nJSON stream.",36],[10,"new","","Create a JSON Builder.",37],[10,"build","","",37],[10,"new","","Creates a new decoder instance for decoding the specified JSON value.",38],[4,"Error","",""],[10,"read_nil","","",38],[10,"read_usize","","",38],[10,"read_u8","","",38],[10,"read_u16","","",38],[10,"read_u32","","",38],[10,"read_u64","","",38],[10,"read_isize","","",38],[10,"read_i8","","",38],[10,"read_i16","","",38],[10,"read_i32","","",38],[10,"read_i64","","",38],[10,"read_f32","","",38],[10,"read_f64","","",38],[10,"read_bool","","",38],[10,"read_char","","",38],[10,"read_str","","",38],[10,"read_enum","","",38],[10,"read_enum_variant","","",38],[10,"read_enum_variant_arg","","",38],[10,"read_enum_struct_variant","","",38],[10,"read_enum_struct_variant_field","","",38],[10,"read_struct","","",38],[10,"read_struct_field","","",38],[10,"read_tuple","","",38],[10,"read_tuple_arg","","",38],[10,"read_tuple_struct","","",38],[10,"read_tuple_struct_arg","","",38],[10,"read_option","","",38],[10,"read_seq","","",38],[10,"read_seq_elt","","",38],[10,"read_map","","",38],[10,"read_map_elt_key","","",38],[10,"read_map_elt_val","","",38],[10,"error","","",38],[10,"to_json","","",26],[10,"to_json","collections::string","",0],[10,"to_json","collections::vec","",3],[10,"to_json","collections::btree::map","",12],[10,"to_json","std::collections::hash::map","",14],[10,"to_json","core::option","",4],[10,"fmt","rustc-serialize::json","Encodes a json value into a string",26],[10,"fmt","","Encodes a json value into a string",39],[10,"fmt","","Encodes a json value into a string",40],[10,"indent","","Set the indentation level for the emitted JSON",41],[10,"fmt","","Encodes a json value into a string",41],[10,"from_str","","",26],[10,"encode","collections::string","",0],[10,"decode","","",0],[10,"encode","alloc::boxed","",1],[10,"decode","","",1],[10,"decode","","",1],[10,"encode","alloc::rc","",2],[10,"decode","","",2],[10,"encode","collections::vec","",3],[10,"decode","","",3],[10,"encode","core::option","",4],[10,"decode","","",4],[10,"encode","std::path::posix","",5],[10,"decode","","",5],[10,"encode","std::path::windows","",6],[10,"decode","","",6],[10,"encode","core::cell","",7],[10,"decode","","",7],[10,"encode","","",8],[10,"decode","","",8],[10,"encode","alloc::arc","",9],[10,"decode","","",9],[6,"Decoder","rustc-serialize",""],[17,"Error","rustc-serialize::Decoder",""],[9,"read_nil","rustc-serialize","",42],[9,"read_usize","","",42],[9,"read_u64","","",42],[9,"read_u32","","",42],[9,"read_u16","","",42],[9,"read_u8","","",42],[9,"read_isize","","",42],[9,"read_i64","","",42],[9,"read_i32","","",42],[9,"read_i16","","",42],[9,"read_i8","","",42],[9,"read_bool","","",42],[9,"read_f64","","",42],[9,"read_f32","","",42],[9,"read_char","","",42],[9,"read_str","","",42],[9,"read_enum","","",42],[9,"read_enum_variant","","",42],[9,"read_enum_variant_arg","","",42],[9,"read_enum_struct_variant","","",42],[9,"read_enum_struct_variant_field","","",42],[9,"read_struct","","",42],[9,"read_struct_field","","",42],[9,"read_tuple","","",42],[9,"read_tuple_arg","","",42],[9,"read_tuple_struct","","",42],[9,"read_tuple_struct_arg","","",42],[9,"read_option","","",42],[9,"read_seq","","",42],[9,"read_seq_elt","","",42],[9,"read_map","","",42],[9,"read_map_elt_key","","",42],[9,"read_map_elt_val","","",42],[9,"error","","",42],[6,"Encoder","",""],[17,"Error","rustc-serialize::Encoder",""],[9,"emit_nil","rustc-serialize","",43],[9,"emit_usize","","",43],[9,"emit_u64","","",43],[9,"emit_u32","","",43],[9,"emit_u16","","",43],[9,"emit_u8","","",43],[9,"emit_isize","","",43],[9,"emit_i64","","",43],[9,"emit_i32","","",43],[9,"emit_i16","","",43],[9,"emit_i8","","",43],[9,"emit_bool","","",43],[9,"emit_f64","","",43],[9,"emit_f32","","",43],[9,"emit_char","","",43],[9,"emit_str","","",43],[9,"emit_enum","","",43],[9,"emit_enum_variant","","",43],[9,"emit_enum_variant_arg","","",43],[9,"emit_enum_struct_variant","","",43],[9,"emit_enum_struct_variant_field","","",43],[9,"emit_struct","","",43],[9,"emit_struct_field","","",43],[9,"emit_tuple","","",43],[9,"emit_tuple_arg","","",43],[9,"emit_tuple_struct","","",43],[9,"emit_tuple_struct_arg","","",43],[9,"emit_option","","",43],[9,"emit_option_none","","",43],[9,"emit_option_some","","",43],[9,"emit_seq","","",43],[9,"emit_seq_elt","","",43],[9,"emit_map","","",43],[9,"emit_map_elt_key","","",43],[9,"emit_map_elt_val","","",43],[6,"Decodable","",""],[9,"decode","","",44],[6,"Encodable","",""],[9,"encode","","",45],[6,"DecoderHelpers","",""],[9,"read_to_vec","","",46],[6,"EncoderHelpers","",""],[9,"emit_from_vec","","",47]],"paths":[[1,"String"],[1,"Box"],[1,"Rc"],[1,"Vec"],[2,"Option"],[1,"Path"],[1,"Path"],[1,"Cell"],[1,"RefCell"],[1,"Arc"],[1,"DList"],[1,"RingBuf"],[1,"BTreeMap"],[1,"BTreeSet"],[1,"HashMap"],[1,"HashSet"],[1,"VecMap"],[1,"Config"],[2,"CharacterSet"],[2,"Newline"],[2,"FromBase64Error"],[6,"ToBase64"],[6,"FromBase64"],[2,"FromHexError"],[6,"ToHex"],[6,"FromHex"],[2,"Json"],[2,"ErrorCode"],[2,"ParserError"],[2,"DecoderError"],[2,"JsonEvent"],[2,"StackElement"],[6,"ToJson"],[1,"Encoder"],[1,"PrettyEncoder"],[1,"Stack"],[1,"Parser"],[1,"Builder"],[1,"Decoder"],[1,"PrettyJson"],[1,"AsJson"],[1,"AsPrettyJson"],[6,"Decoder"],[6,"Encoder"],[6,"Decodable"],[6,"Encodable"],[6,"DecoderHelpers"],[6,"EncoderHelpers"]]};

searchIndex['regex'] = {"items":[[0,"","regex","This crate provides a native implementation of regular expressions that is\nheavily based on RE2 both in syntax and in implementation. Notably,\nbackreferences and arbitrary lookahead/lookbehind assertions are not\nprovided. In return, regular expression searching provided by this package\nhas excellent worst case performance. The specific syntax supported is\ndocumented further down."],[1,"Error","","Error corresponds to something that can go wrong while parsing\na regular expression."],[11,"pos","","The *approximate* character index of where the error occurred.",0],[11,"msg","","A message describing the error.",0],[1,"Captures","","Captures represents a group of captured strings for a single match."],[1,"SubCaptures","","An iterator over capture groups for a particular match of a regular\nexpression."],[1,"SubCapturesPos","","An iterator over capture group positions for a particular match of a\nregular expression."],[1,"FindCaptures","","An iterator that yields all non-overlapping capture groups matching a\nparticular regular expression."],[1,"FindMatches","","An iterator over all non-overlapping matches for a particular string."],[1,"NoExpand","","NoExpand indicates literal string replacement."],[1,"RegexSplits","","Yields all substrings delimited by a regular expression match."],[1,"RegexSplitsN","","Yields at most `N` substrings delimited by a regular expression match."],[2,"Regex","","A compiled regular expression"],[3,"quote","","Escapes all regular expression meta characters in `text`."],[3,"is_match","","Tests if the given regular expression matches somewhere in the text given."],[10,"fmt","","",0],[10,"fmt","","",0],[10,"clone","","",1],[10,"fmt","","Shows the original regular expression.",1],[10,"fmt","","Shows the original regular expression.",1],[10,"new","","Compiles a dynamic regular expression. Once compiled, it can be\nused repeatedly to search, split or replace text in a string.",1],[10,"is_match","","Returns true if and only if the regex matches the string given.",1],[10,"find","","Returns the start and end byte range of the leftmost-first match in\n`text`. If no match exists, then `None` is returned.",1],[10,"find_iter","","Returns an iterator for each successive non-overlapping match in\n`text`, returning the start and end byte indices with respect to\n`text`.",1],[10,"captures","","Returns the capture groups corresponding to the leftmost-first\nmatch in `text`. Capture group `0` always corresponds to the entire\nmatch. If no match is found, then `None` is returned.",1],[10,"captures_iter","","Returns an iterator over all the non-overlapping capture groups matched\nin `text`. This is operationally the same as `find_iter` (except it\nyields information about submatches).",1],[10,"split","","Returns an iterator of substrings of `text` delimited by a match\nof the regular expression.\nNamely, each element of the iterator corresponds to text that *isn't*\nmatched by the regular expression.",1],[10,"splitn","","Returns an iterator of at most `limit` substrings of `text` delimited\nby a match of the regular expression. (A `limit` of `0` will return no\nsubstrings.)\nNamely, each element of the iterator corresponds to text that *isn't*\nmatched by the regular expression.\nThe remainder of the string that is not split will be the last element\nin the iterator.",1],[10,"replace","","Replaces the leftmost-first match with the replacement provided.\nThe replacement can be a regular string (where `$N` and `$name` are\nexpanded to match capture groups) or a function that takes the matches'\n`Captures` and returns the replaced string.",1],[10,"replace_all","","Replaces all non-overlapping matches in `text` with the\nreplacement provided. This is the same as calling `replacen` with\n`limit` set to `0`.",1],[10,"replacen","","Replaces at most `limit` non-overlapping matches in `text` with the\nreplacement provided. If `limit` is 0, then all non-overlapping matches\nare replaced.",1],[10,"as_str","","Returns the original string of this regex.",1],[10,"reg_replace","","",2],[10,"next","","",3],[10,"next","","",4],[10,"pos","","Returns the start and end positions of the Nth capture group.\nReturns `None` if `i` is not a valid capture group or if the capture\ngroup did not match anything.\nThe positions returned are *always* byte indices with respect to the\noriginal string matched.",5],[10,"at","","Returns the matched string for the capture group `i`.  If `i` isn't\na valid capture group or didn't match anything, then `None` is\nreturned.",5],[10,"name","","Returns the matched string for the capture group named `name`.  If\n`name` isn't a valid capture group or didn't match anything, then\n`None` is returned.",5],[10,"iter","","Creates an iterator of all the capture groups in order of appearance\nin the regular expression.",5],[10,"iter_pos","","Creates an iterator of all the capture group positions in order of\nappearance in the regular expression. Positions are byte indices\nin terms of the original string matched.",5],[10,"expand","","Expands all instances of `$name` in `text` to the corresponding capture\ngroup `name`.",5],[10,"len","","Returns the number of captured groups.",5],[10,"is_empty","","Returns if there are no captured groups.",5],[10,"next","","",6],[10,"next","","",7],[10,"next","","",8],[10,"next","","",9],[6,"Replacer","","Replacer describes types that can be used to replace matches in a string."],[9,"reg_replace","","Returns a possibly owned string that is used to replace the match\ncorresponding to the `caps` capture group.",10]],"paths":[[1,"Error"],[2,"Regex"],[1,"NoExpand"],[1,"RegexSplits"],[1,"RegexSplitsN"],[1,"Captures"],[1,"SubCaptures"],[1,"SubCapturesPos"],[1,"FindCaptures"],[1,"FindMatches"],[6,"Replacer"]]};

searchIndex['matches'] = {"items":[[0,"","matches",""],[15,"matches!","",""],[15,"_tt_as_expr_hack!","","Work around \"error: unexpected token: `an interpolated tt`\", whatever that means."]],"paths":[]};

initSearch(searchIndex);
